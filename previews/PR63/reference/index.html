<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference ¬∑ HierarchicalTemporalMemory.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://oblynx.github.io/HierarchicalTemporalMemory.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="HierarchicalTemporalMemory.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="HierarchicalTemporalMemory.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">HierarchicalTemporalMemory.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">Hierarchical Temporal Memory</a></li><li><a class="tocitem" href="../poster/">JuliaCon 2020 poster</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Package-documentation"><a class="docs-heading-anchor" href="#Package-documentation">Package documentation</a><a id="Package-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Package-documentation" title="Permalink"></a></h1><ul><li><a href="#HierarchicalTemporalMemory.ùïäùï¢range"><code>HierarchicalTemporalMemory.ùïäùï¢range</code></a></li><li><a href="#HierarchicalTemporalMemory.CellActivity"><code>HierarchicalTemporalMemory.CellActivity</code></a></li><li><a href="#HierarchicalTemporalMemory.DistalSynapses"><code>HierarchicalTemporalMemory.DistalSynapses</code></a></li><li><a href="#HierarchicalTemporalMemory.Hypercube"><code>HierarchicalTemporalMemory.Hypercube</code></a></li><li><a href="#HierarchicalTemporalMemory.Hypersphere"><code>HierarchicalTemporalMemory.Hypersphere</code></a></li><li><a href="#HierarchicalTemporalMemory.LengthfulIter"><code>HierarchicalTemporalMemory.LengthfulIter</code></a></li><li><a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>HierarchicalTemporalMemory.ProximalSynapses</code></a></li><li><a href="#HierarchicalTemporalMemory.Region"><code>HierarchicalTemporalMemory.Region</code></a></li><li><a href="#HierarchicalTemporalMemory.SPParams"><code>HierarchicalTemporalMemory.SPParams</code></a></li><li><a href="#HierarchicalTemporalMemory.Sequence"><code>HierarchicalTemporalMemory.Sequence</code></a></li><li><a href="#HierarchicalTemporalMemory.SpatialPooler-Tuple{Any}"><code>HierarchicalTemporalMemory.SpatialPooler</code></a></li><li><a href="#HierarchicalTemporalMemory.SpatialPooler"><code>HierarchicalTemporalMemory.SpatialPooler</code></a></li><li><a href="#HierarchicalTemporalMemory.TMParams"><code>HierarchicalTemporalMemory.TMParams</code></a></li><li><a href="#HierarchicalTemporalMemory.TMState"><code>HierarchicalTemporalMemory.TMState</code></a></li><li><a href="#HierarchicalTemporalMemory.TemporalMemory"><code>HierarchicalTemporalMemory.TemporalMemory</code></a></li><li><a href="#HierarchicalTemporalMemory.TemporalMemory"><code>HierarchicalTemporalMemory.TemporalMemory</code></a></li><li><a href="#HierarchicalTemporalMemory.Truesof"><code>HierarchicalTemporalMemory.Truesof</code></a></li><li><a href="#HierarchicalTemporalMemory.ùïäùï¢"><code>HierarchicalTemporalMemory.ùïäùï¢</code></a></li><li><a href="#HierarchicalTemporalMemory.bestmatch-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any}"><code>HierarchicalTemporalMemory.bestmatch</code></a></li><li><a href="#HierarchicalTemporalMemory.bitarray-Tuple{Any, Any}"><code>HierarchicalTemporalMemory.bitarray</code></a></li><li><a href="#HierarchicalTemporalMemory.calculate_WS!-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any, Any, Any}"><code>HierarchicalTemporalMemory.calculate_WS!</code></a></li><li><a href="#HierarchicalTemporalMemory.countmap_empty-Tuple{Any}"><code>HierarchicalTemporalMemory.countmap_empty</code></a></li><li><a href="#HierarchicalTemporalMemory.decayS-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any}"><code>HierarchicalTemporalMemory.decayS</code></a></li><li><a href="#HierarchicalTemporalMemory.growseg!-Tuple{HierarchicalTemporalMemory.DistalSynapses, Vector{Union{Nothing, Int64}}, Any}"><code>HierarchicalTemporalMemory.growseg!</code></a></li><li><a href="#HierarchicalTemporalMemory.growsynapses!-Tuple{HierarchicalTemporalMemory.DistalSynapses, BitArray, Any, Any}"><code>HierarchicalTemporalMemory.growsynapses!</code></a></li><li><a href="#HierarchicalTemporalMemory.hcat!!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any}"><code>HierarchicalTemporalMemory.hcat!!</code></a></li><li><a href="#HierarchicalTemporalMemory.leastusedcell-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any}"><code>HierarchicalTemporalMemory.leastusedcell</code></a></li><li><a href="#HierarchicalTemporalMemory.predict!-Tuple{SDRClassifier, Any, Int64}"><code>HierarchicalTemporalMemory.predict!</code></a></li><li><a href="#HierarchicalTemporalMemory.reverse_simpleArithmetic-Tuple{Vector{T} where T, Any, Any}"><code>HierarchicalTemporalMemory.reverse_simpleArithmetic</code></a></li><li><a href="#HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}"><code>HierarchicalTemporalMemory.sp_activate</code></a></li><li><a href="#HierarchicalTemporalMemory.sparse_foreach-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}"><code>HierarchicalTemporalMemory.sparse_foreach</code></a></li><li><a href="#HierarchicalTemporalMemory.sparse_map-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}"><code>HierarchicalTemporalMemory.sparse_map</code></a></li><li><a href="#HierarchicalTemporalMemory.step!-Tuple{HierarchicalTemporalMemory.ProximalSynapses, Any, Any, Any}"><code>HierarchicalTemporalMemory.step!</code></a></li><li><a href="#HierarchicalTemporalMemory.step!-Tuple{SpatialPooler, Any}"><code>HierarchicalTemporalMemory.step!</code></a></li><li><a href="#HierarchicalTemporalMemory.step_boost!-Tuple{SpatialPooler, Any}"><code>HierarchicalTemporalMemory.step_boost!</code></a></li><li><a href="#HierarchicalTemporalMemory.tm_activate-Tuple{TemporalMemory, Any, Any}"><code>HierarchicalTemporalMemory.tm_activate</code></a></li><li><a href="#HierarchicalTemporalMemory.tm_predict-Tuple{TemporalMemory, BitArray}"><code>HierarchicalTemporalMemory.tm_predict</code></a></li><li><a href="#HierarchicalTemporalMemory.vcat!!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any}"><code>HierarchicalTemporalMemory.vcat!!</code></a></li><li><a href="#HierarchicalTemporalMemory.@percolumn-NTuple{4, Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a></li><li><a href="#HierarchicalTemporalMemory.@percolumn-Tuple{Any, Any, Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.ùïäùï¢range" href="#HierarchicalTemporalMemory.ùïäùï¢range"><code>HierarchicalTemporalMemory.ùïäùï¢range</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>ùïäùï¢range is the domain of connection permanence quantization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/HierarchicalTemporalMemory.jl#LL20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.CellActivity" href="#HierarchicalTemporalMemory.CellActivity"><code>HierarchicalTemporalMemory.CellActivity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Type of neuron layer activations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/HierarchicalTemporalMemory.jl#LL23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.DistalSynapses" href="#HierarchicalTemporalMemory.DistalSynapses"><code>HierarchicalTemporalMemory.DistalSynapses</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistalSynapses(N‚Çô, Nc, k; Nseg_init=0, params)</code></pre><p><code>DistalSynapses</code> are lateral connections within a neuron layer that attach to the dendrites of neurons, not directly to the soma (neuron&#39;s center), and can therefore <strong>depolarize</strong> neurons but <em>can&#39;t activate them.</em> Compare with <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>. Used in the context of the <a href="#HierarchicalTemporalMemory.TemporalMemory"><code>TemporalMemory</code></a>.</p><p>Parameters:</p><ul><li>N‚Çô: number of presynaptic neurons</li><li>Nc: number of minicolumns in layer</li><li>k: neurons per minicolumn</li><li>Nseg_init: how many dendritic segments to begin with. More grow as needed while learning.</li><li>params: <a href="@ref"><code>DistalSynapseParams</code></a> with learning rates etc</li></ul><p><strong>Description</strong></p><p><strong>Synapses</strong></p><p>Neurons have multiple signal integration zones: the soma, proximal dendrites, apical dendrites. Signals are routed to the proximal dendrites through <em>distal synapses</em>. This type defines both the synapses themselves and the neuron&#39;s dendrites. The synapses themselves, like the <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>, are binary connections without weights. They have a <strong>permanence value</strong>, and above a threshold they are connected.</p><p>The synapses can be represented as an adjacency matrix of dimensions <code>N‚Çô √ó N‚Çõ</code>: presynaptic neurons -&gt; postsynaptic dendritic segments. This matrix is derived from the synapse permanence matrix <span>$D_d ‚àà \mathit{ùïäùï¢}^{N‚Çô √ó N‚Çõ}$</span>, which is <strong>sparse</strong> (eg 0.5% synapses). This affects the implementation of all low-level operations.</p><p><strong>Dendritic segments</strong></p><p>Neurons have multiple dendritic segments carrying the distal synapses, each sufficient to depolarize the neuron (make it predictive). The neuron/segment adjacency matrix <code>neurSeg</code> (aka <code>NS</code>) also has dimensions <code>N‚Çô √ó N‚Çõ</code>.</p><p><strong>Learning</strong></p><p>Instead of being randomly initialized like the proximal synapses, distal synapses and dendrite segments are grown on demand: when minicolumns can&#39;t predict their activation and burst, they trigger a growth process.</p><p>The synaptic permanence itself adapts similar to the proximal synapses: synapses that correctly predict are increased, synapses that incorrectly predict are decreased. However it&#39;s a bit more complicated to define the successful distal syapses than the proximal synapses. &quot;Winning segments&quot; <code>WS</code> will adapt their synapses towards &quot;winning neurons&quot; <code>WN</code>. Since synapses are considered directional, neurons are always presynaptic and segments postsynaptic.</p><p>Winning segments are those that were predicted and then activated. Also, for every bursting minicolumn the dendrite that best &quot;matches&quot; the input will become winner. If there is no sufficiently matching dendrite, a new onw will grow on the neuron that has the fewest.</p><p>Winning neurons are again those that were predicted and then activated. Among the bursting minicolumns, the neurons bearing the winning segments are the winners. Both definitions of winners are aligned with establishing a causal relationship: prediction -&gt; activation.</p><p>New synapses grow from <code>WS</code> towards a random sample of <code>WN</code> at every step. Strongly matching segments have a lower chance to grow new synapses than weakly matching segments.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Adding new synapses at random indices of <code>Dd::SparseMatrixCSC</code> is a performance bottleneck, because it involves moving the matrix&#39;s existing data. An implementation of <code>SparseMatrixCSC</code> with hashmaps could help, such as <a href="https://github.com/jw3126/SimpleSparseArrays.jl/">SimpleSparseArrays.jl</a></p></div></div><p><strong>Caching</strong></p><p>The state of the DistalSynapses is determined by the 2 matrices <span>$D_d, \mathit{NS}$</span>. A few extra matrices are filled in over the evolution of the distal synapses to accelerate the computations:</p><ul><li><code>connected</code> caches <code>Dd &gt; Œ∏_permanence</code></li><li><code>segCol</code> caches the segment - column map (aka <code>SC</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL154-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Hypercube" href="#HierarchicalTemporalMemory.Hypercube"><code>HierarchicalTemporalMemory.Hypercube</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Hypercube iterates over a hypercube of radius Œ≥ around x·∂ú, bounded inside the space {1..sz}·¥∫.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hc= Hypercube((3,3),1,(10,10));

julia&gt; foreach(println, hc)
(2, 2)
(3, 2)
(4, 2)
(2, 3)
(3, 3)
(4, 3)
(2, 4)
(3, 4)
(4, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/topology.jl#LL1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Hypersphere" href="#HierarchicalTemporalMemory.Hypersphere"><code>HierarchicalTemporalMemory.Hypersphere</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Hypersphere is approximated with a Hypercube for simplicity</p><p>See also: <a href="#HierarchicalTemporalMemory.Hypercube"><code>Hypercube</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/topology.jl#LL48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.LengthfulIter" href="#HierarchicalTemporalMemory.LengthfulIter"><code>HierarchicalTemporalMemory.LengthfulIter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>LengthfulIter</code> is an iterator wrapper that allows length info known programmatically to be used. It&#39;s used because iterator transformations, like filters, don&#39;t keep the length info, which might however be known to the programmer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.ProximalSynapses" href="#HierarchicalTemporalMemory.ProximalSynapses"><code>HierarchicalTemporalMemory.ProximalSynapses</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>ProximalSynapses{SynapseT&lt;:AnySynapses,ConnectedT&lt;:AnyConnection} are the feedforward connections between 2 neuron layers, which can activate neurons and cause them to fire.</p><p>Used in the context of the <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a>.</p><p><strong>Description</strong></p><p>The neurons of both layers are expected to form minicolumns which share the same feedforward connections. The synapses are <em>binary</em>: they don&#39;t have a scalar weight, but either conduct (1) or not (0). Instead, they have a <em>permanence</em> value D‚Çö ‚àà (0,1] and a connection threshold Œ∏.</p><p><strong>Initialization</strong></p><p>Let presynaptic (input) neuron <code>x·µ¢</code> and postsynaptic (output) neuron <code>y·µ¢</code>, and a topological I/O mapping <code>x·µ¢(y·µ¢) :=</code> <a href="#HierarchicalTemporalMemory.Hypercube"><code>Hypercube</code></a><code>(y·µ¢)</code>. ‚àÄ</p><p><strong>Synapse adaptation</strong></p><p>They adapt with a hebbian learning rule. The adaptation has a causal and an anticausal component:</p><ul><li>If the postsynaptic neuron fires and the presynaptic fired too, the synapse is strengthened</li><li>If the postsynaptic neuron fires, but the presynaptic didn&#39;t, the synapse is weakened</li></ul><p>The synaptic permanences are clipped at the boundaries of 0 and 1.</p><p>A simple implementation of the learning rule would look like this, where z: input, a: output</p><pre><code class="language-julia hljs">learn!(D‚Çö,z,a)= begin
  D‚Çö[z,a]  .= (D‚Çö[z,a].&gt;0) .* (D‚Çö[z,a]   .‚äï p‚Å∫)
  D‚Çö[.!z,a].= (D‚Çö[z,a].&gt;0) .* (D‚Çö[.!z,a] .‚äñ p‚Åª)
end</code></pre><p><strong>Type parameters</strong></p><p>They allow a dense or sparse matrix representation of the synapses</p><ul><li><code>SynapseT</code>: <code>DenseSynapses</code> or <code>SparseSynapses</code></li><li><code>ConnectedT</code>: <code>DenseConnection</code> or <code>SparseConnection</code></li></ul><p>See also: <a href="#HierarchicalTemporalMemory.DistalSynapses"><code>DistalSynapses</code></a>, <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a>, <a href="#HierarchicalTemporalMemory.TemporalMemory"><code>TemporalMemory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL3-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Region" href="#HierarchicalTemporalMemory.Region"><code>HierarchicalTemporalMemory.Region</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Region(SPParams, TMParams; recurrent= true)</code></pre><p>A Region is a set of neurons arranged in minicolumns with 2 input gates:</p><ul><li><em>proximal</em> (size: number of minicolumns Nc): feedforward input that activates some of the region&#39;s minicolumns</li><li><em>distal</em> (size: number of neurons Nn): contextual input that causes individual neurons to become predictive and fire preferentially on the next time step</li></ul><p>Each gate accepts 1 or more input SDRs of the correct size, which will be ORed together. If <code>recurrent= true</code>, the distal gate implicitly receives the same layer&#39;s state from the last time step as input (in addition to any SDR given explicitly).</p><p>The activation of minicolumns resulting from the proximal synapses is defined by the <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a> algorithm, while the activation of individual neurons is defined by the <a href="#HierarchicalTemporalMemory.TemporalMemory"><code>TemporalMemory</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">r= Region(SPParams(), TMParams(), recurrent= true)
feedforward_input= bitrand(Nc(r))

# activate based on feedforward input and the region&#39;s previous activation
active, predictive= r(feedforward_input)
# learn (adapt synapses)
step!(r, feedforward_input)

# use explicit contextual input eg from another region, that will be ORed to the region&#39;s state
distal_input= sprand(Bool,Nn(r), 0.003)|&gt; BitVector
active, predictive= r(feedforward_input, distal_input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/Region.jl#LL1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.SPParams" href="#HierarchicalTemporalMemory.SPParams"><code>HierarchicalTemporalMemory.SPParams</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>SPParams</code> holds the algorithm parameters for a spatial pooler with nomenclature similar to <a href="https://www.frontiersin.org/articles/10.3389/fncom.2017.00111/full">source</a></p><p>The dimension parameters are problem-specific and should be the first to be specified.</p><p>The tuning parameters have sensible defaults, which should be . All gated features are enabled by default.</p><p><strong>Parameters</strong></p><p><strong>Dimensions</strong></p><ul><li><code>sz·µ¢‚Çô = (32,32)</code>: input dimensions</li><li><code>sz‚Çõ‚Çö = (32,32)</code>: output dimensions</li><li><code>Œ≥ = 6</code>: receptive field radius (how large an input area an output minicolumn maps to). Must be &lt;= min(sz·µ¢‚Çô)</li></ul><p><strong>Algorithm tuning</strong></p><ul><li><code>s = .02</code>: average output sparsity</li><li><code>prob_synapse = .5</code>: probability for each element of the <code>sz·µ¢‚Çô √ó sz‚Çõ‚Çö</code> space to be a synapse. Elements that roll below this value don&#39;t form a synapse and don&#39;t get a permanence value. If this is very low, the proximal synapses matrix can become sparse.</li><li><code>Œ∏_permanence01 = .5</code>: synapse permanence connection threshold</li><li><code>p‚Å∫_01 = .1 , p‚Åª_01 = .02</code>: synapse permanence adaptation rate (see <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>)</li><li><code>Œ∏_stimulus_activate = 1</code>: minicolumn absolute activation threshold</li><li><code>Tboost = 200.0</code>: boosting mechanism&#39;s moving average filter period</li><li><code>Œ≤ = 1.0</code>: boosting strength</li></ul><p><strong>Feature gates</strong></p><ul><li><code>enable_local_inhibit = true</code></li><li><code>enable_learning = true</code></li><li><code>enable_boosting = true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/algorithm_parameters.jl#LL1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Sequence" href="#HierarchicalTemporalMemory.Sequence"><code>HierarchicalTemporalMemory.Sequence</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>Sequence(;Œ¥,init)</code> is an easy way to define sequences with transition function <code>Œ¥</code> and starting condition <code>init</code> as an iterator.</p><p><strong>Examples</strong></p><p>Fibonacci sequence:</p><pre><code class="language-julia hljs">fibonacci_Œ¥(a,b)= b, a+b;
fibonacci_init= 0,1;
Lazy.@as _1 HTM.Sequence(fibonacci_Œ¥, fibonacci_init) IterTools.take(_1, 13) foreach(println, _1)

# output
0
1
1
2
3
5
8
13
21
34
55
89
144</code></pre><p>Factorial sequence:</p><pre><code class="language-julia hljs">factorial_Œ¥(a,b)= a*b, b+1;
factorial_init= 1,1;
Lazy.@as _1 HTM.Sequence(factorial_Œ¥, factorial_init) IterTools.take(_1, 13) foreach(println, _1)

# output
1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL119-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.SpatialPooler" href="#HierarchicalTemporalMemory.SpatialPooler"><code>HierarchicalTemporalMemory.SpatialPooler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>SpatialPooler</code> is a learning algorithm that decorrelates the features of an input space, producing a Sparse Distributed Representation (SDR) of the input space. If defines the proximal connections of an HTM layer.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sp= SpatialPooler(SPParams(sz·µ¢‚Çô=(600,), sz‚Çõ‚Çö=(2048,)))
z= Random.bitrand(600)  # input
activation= sp(z)
# or, to adapt the SP to the input as well:
activation= step!(sp,z)</code></pre><p><strong>Properties</strong></p><p>It&#39;s called <code>SpatialPooler</code> because input patterns that share a large number of co-active neurons (i.e., that are spatially similar) are grouped together into a common output representation. It is designed to achieve a set of <em>computational properties</em> that support further downstream computations with SDRs, including:</p><ul><li>preserving topology of the input space by mapping similar inputs to similar outputs</li><li>continuously adapting to changing statistics of the input stream</li><li>forming fixed sparsity representations</li><li>being robust to noise</li><li>being fault tolerant</li></ul><p><a href="https://www.frontiersin.org/articles/10.3389/fncom.2017.00111/full">Source</a></p><p><strong>Algorithm overview</strong></p><p><strong>Mapping I/O spaces</strong></p><p>The spatial pooler maps an input space <code>x</code> to an output space <code>y</code> of minicolumns through a matrix of proximal synapses. The input space can optionally have a topology, which the spatial pooler will preserve by mapping output minicolumn <code>y·µ¢</code> to a subset of the input space, a <a href="#HierarchicalTemporalMemory.Hypercube"><code>Hypercube</code></a> around center <code>x·∂ú</code>. <code>julia x·∂ú(y·µ¢)= floor.(Int, (y·µ¢.-1) .* (sz·µ¢‚Çô./sz‚Çõ‚Çö)) .+1</code>`</p><p><strong>Output activation</strong></p><ol><li>Calculate the overlap <code>o(y·µ¢)</code> by propagating the input activations through the proximal synapses and adjusting by boosting factors <code>b</code> (control mechanism that spreads out the activation pattern across understimulated neurons)</li><li>Inhibition <code>Z</code> between <code>y·µ¢</code> (local/global): competition where only the top-K <code>y·µ¢</code> with the highest <code>o(y·µ¢)</code> win; ensures sparsity</li><li>Activate winning <code>y·µ¢</code> &gt; activation threshold (<code>Œ∏_stimulus_activate</code>)</li></ol><p>See also: <a href="#HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}"><code>sp_activate</code></a></p><p><strong>State variables</strong></p><ul><li><code>synapses</code>: includes the synapse permanence matrix D‚Çö</li><li><code>√•‚Çú</code>: [boosting] moving (in time) average (in time) activation of each minicolumn</li><li><code>√•‚Çô</code>: [boosting] moving (in time) average (in neighborhood) activation of each minicolumn</li><li><code>œÜ</code>: the adaptible radius of local inhibition</li></ul><hr/><p>See also: <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>, <a href="#HierarchicalTemporalMemory.TemporalMemory"><code>TemporalMemory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/SpatialPooler.jl#LL1-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.SpatialPooler-Tuple{Any}" href="#HierarchicalTemporalMemory.SpatialPooler-Tuple{Any}"><code>HierarchicalTemporalMemory.SpatialPooler</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the activation pattern of the <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a> for the given input activation.</p><p><code>z</code>: <a href="#HierarchicalTemporalMemory.CellActivity"><code>CellActivity</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sp= SpatialPooler(SPParams(sz·µ¢‚Çô=(600,), sz‚Çõ‚Çö=(2048,)))
z= Random.bitrand(600)  # input
activation= sp(z)
# or, to adapt the SP to the input as well:
activation= step!(sp,z)</code></pre><p>For details see: <a href="#HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}"><code>sp_activate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/SpatialPooler.jl#LL104-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.TMParams" href="#HierarchicalTemporalMemory.TMParams"><code>HierarchicalTemporalMemory.TMParams</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>TMParams</code> holds the algorithm parameters for a Temporal Memory with nomenclature similar to <a href=".">source</a></p><p><strong>Dimensions</strong></p><ul><li><code>Nc = 2500</code>: number of columns</li><li><code>k = 10</code>: cells per column</li><li><code>N‚Çô = k Nc</code> neurons in layer. The <code>N‚Çõ</code> number of dendritic segments is variable</li></ul><p><strong>Tuning</strong></p><ul><li><code>p‚Å∫_01 = .12 , p‚Åª_01 = .04 ‚àà [0,1]</code>: synapse permanence adaptation rate (see <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>)</li><li><code>LTD_p‚Åª_01 = .002 ‚àà [0,1]</code>: synapse long term depression rate</li><li><code>Œ∏_permanence = .5*typemax(ùïäùï¢) ‚àà ùïäùï¢</code>: synapse permanence connection threshold</li><li><code>init_permanence = .4*typemax(ùïäùï¢) ‚àà ùïäùï¢</code>: permanence of a newly-grown synapse</li><li><code>synapseSampleSize = 25 ‚àà ‚Ñï</code>: target number of matching synapses per dendrite. Represents how many bits the dendrite targets to recognize the input. Dendrites with fewer synapses matching the input might grow new synapses.</li><li><code>Œ∏_stimulus_activate = 14 ‚àà ‚Ñï</code>: number of matching synapses needed to depolarize the dendrite</li><li><code>Œ∏_stimulus_learn = 12 ‚àà ‚Ñï</code>: number of matching synapses that are insufficient to depolarize the dendrite, but sufficient to trigger learning. <code>Œ∏_stimulus_learn &lt;= Œ∏_stimulus_activate</code></li></ul><p><strong>Feature gates</strong></p><ul><li><code>enable_learning = true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/algorithm_parameters.jl#LL61-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.TMState" href="#HierarchicalTemporalMemory.TMState"><code>HierarchicalTemporalMemory.TMState</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>TMState</code> is a named tuple of the state variables of a temporal memory.</p><ul><li><code>Œ±</code>: active neurons</li><li><code>Œ†</code>: predictive neurons</li><li><code>WN</code>: winning neurons</li><li><code>Œ†‚Çõ</code>: predictive dendritic segments (to calculate winning segments)</li><li><code>M‚Çõ</code>: matching dendritic segments (didn&#39;t receive enough input to activate, but enough to learn)</li><li><code>ovp_M‚Çõ</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/TemporalMemory.jl#LL5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.TemporalMemory" href="#HierarchicalTemporalMemory.TemporalMemory"><code>HierarchicalTemporalMemory.TemporalMemory</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TemporalMemory(params::TMParams; recurrent= true, distal_input_size=0)</code></pre><p><code>TemporalMemory</code> learns to predict sequences of input Sparse Distributed Representations (SDRs), usually generated by a <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a>. It learns to represent each input symbol in the temporal context of the symbols that come before it in the sequence, using the individual neurons of each minicolumn and their distal synapses.</p><p>When considering a neuron layer with proximal and distal synapses, the spatial pooler is a way to activate and learn the proximal synapses, while the temporal memory is a way to activate and learn the distal synapses.</p><p>Parameters:</p><ul><li><code>params</code>: <a href="#HierarchicalTemporalMemory.TMParams"><code>TMParams</code></a> defining the layer size and algorithm constants</li><li><code>recurrent</code>: presence of recurrent distal connections between the layer&#39;s neurons</li><li><code>distal_input_size</code>: the number of presynaptic neurons for each layer with incoming distal connections (apart from same layer&#39;s neurons)</li></ul><p><strong>High-order predictions and Ambiguity</strong></p><p>The <a href="https://www.frontiersin.org/articles/10.3389/fncir.2016.00023/full">neurons-thousand-synapses paper</a> describes the Temporal Memory&#39;s properties, and especially the ability to</p><ul><li>make &quot;high-order&quot; predictions, based on previous inputs potentially going far back in time</li><li>represent ambiguity in the form of simultaneous predictions</li></ul><p>For more information see figures 2,3 in the paper.</p><p><strong>TM activation</strong></p><p>Overview of the temporal memory&#39;s process:</p><ol><li>Activate neurons (fire, proximal synapses)</li><li>Predict neurons (depolarize, distal/apical synapses)</li><li>Learn distal/apical synapses:<ul><li>adapt existing synapses</li><li>create new synapses/dendrites</li></ul></li></ol><p><strong>Activation</strong></p><p>An SDR input activates some minicolumns of the neuron layer. If some neurons in the minicolum were predicted at the previous step, they activate faster than the rest and inhibit them. If no neuron was predicted, all the neurons fire (minicolumn bursting).</p><p>TODO</p><hr/><p>See also: <a href="#HierarchicalTemporalMemory.TMParams"><code>TMParams</code></a> for parameter and symbol description, <a href="#HierarchicalTemporalMemory.DistalSynapses"><code>DistalSynapses</code></a>, <a href="#HierarchicalTemporalMemory.TMState"><code>TMState</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/TemporalMemory.jl#LL41-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.TemporalMemory" href="#HierarchicalTemporalMemory.TemporalMemory"><code>HierarchicalTemporalMemory.TemporalMemory</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Active and predictive cells given the minicolumn activations and any distal input.</p><p>See also: <a href="#HierarchicalTemporalMemory.tm_activate-Tuple{TemporalMemory, Any, Any}"><code>tm_activate</code></a>, <a href="#HierarchicalTemporalMemory.tm_predict-Tuple{TemporalMemory, BitArray}"><code>tm_predict</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/TemporalMemory.jl#LL149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Truesof" href="#HierarchicalTemporalMemory.Truesof"><code>HierarchicalTemporalMemory.Truesof</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>TruesOf</code> is a non-allocating version of <code>findall</code>: iterates over the trues of a <code>BitArray</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b= Random.bitrand(5)
5-element BitVector:
 1
 1
 1
 0
 0

julia&gt; foreach(i-&gt; print(string(i)*&quot; &quot;), HTM.Truesof(b))
1 2 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL26-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.ùïäùï¢" href="#HierarchicalTemporalMemory.ùïäùï¢"><code>HierarchicalTemporalMemory.ùïäùï¢</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>ùïäùï¢ is the type of connection permanences, defining their quantization domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/HierarchicalTemporalMemory.jl#LL18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.bestmatch-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any}" href="#HierarchicalTemporalMemory.bestmatch-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any}"><code>HierarchicalTemporalMemory.bestmatch</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>bestmatch(s::DistalSynapses,col, povp_M‚Çõ)</code> finds the best-matching segment in a column, as long as its overlap with the input (its activation) is &gt; Œ∏<em>stimulus</em>learn. Otherwise, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.bitarray-Tuple{Any, Any}" href="#HierarchicalTemporalMemory.bitarray-Tuple{Any, Any}"><code>HierarchicalTemporalMemory.bitarray</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>bitarray(dims, idx)</code></p><p>Create a bitarray with <code>true</code> only at <code>idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.calculate_WS!-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any, Any, Any}" href="#HierarchicalTemporalMemory.calculate_WS!-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any, Any, Any}"><code>HierarchicalTemporalMemory.calculate_WS!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>calculate_WS!(pŒ†‚Çõ,povp_M‚Çõ, Œ±,B)</code> finds the winning segments, growing new ones where necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL300-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.countmap_empty-Tuple{Any}" href="#HierarchicalTemporalMemory.countmap_empty-Tuple{Any}"><code>HierarchicalTemporalMemory.countmap_empty</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>countmap_empty(x)</code> [Dict] Count the frequency of occurence for each element in x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL406-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.decayS-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any}" href="#HierarchicalTemporalMemory.decayS-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any, Any}"><code>HierarchicalTemporalMemory.decayS</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>decayS(s::DistalSynapses,pM‚Çõ,Œ±)</code> are the dendritic segments that should decay according to LTD (long term depression). It&#39;s the segments that at the previous moment had enough potential synapses with active neurons to &quot;match&quot; the input (<code>pM‚Çõ</code>), but didn&#39;t contribute to their neuron firing at this moment (they didn&#39;t activate strongly enough to depolarize it).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.growseg!-Tuple{HierarchicalTemporalMemory.DistalSynapses, Vector{Union{Nothing, Int64}}, Any}" href="#HierarchicalTemporalMemory.growseg!-Tuple{HierarchicalTemporalMemory.DistalSynapses, Vector{Union{Nothing, Int64}}, Any}"><code>HierarchicalTemporalMemory.growseg!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>growseg!(s::DistalSynapses,WS_col::Vector{Option{Int}},burstingcolidx)</code> grows 1 new segment for each column with <code>nothing</code> as winning segment and replaces <code>nothing</code> with it. It resizes all the <code>DistalSynapses</code> matrices to append new dendritic segments. Foreach bursting minicolumn without a winning segment, the neuron to grow the segment is the one with the fewest segments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL383-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.growsynapses!-Tuple{HierarchicalTemporalMemory.DistalSynapses, BitArray, Any, Any}" href="#HierarchicalTemporalMemory.growsynapses!-Tuple{HierarchicalTemporalMemory.DistalSynapses, BitArray, Any, Any}"><code>HierarchicalTemporalMemory.growsynapses!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>growsynapses!(s::DistalSynapses, pWN::CellActivity,WS, povp_M‚Çõ)</code> adds synapses between winning dendrites (<code>WS</code>) and a random sample of previously winning neurons (<code>pWN</code>).</p><p>For each dendrite, target neurons are selected among <code>pWN</code> with probability to pick each neuron determined by <span>$\frac{ (\mathit{synapseSampleSize} - \mathit{prev_Overlap} }{ length(\mathit{pWN}) }$</span> (Bernoulli sampling)</p><p>This involves inserting new elements in random places of a <code>SparseMatrixCSC</code> and is the algorithm&#39;s performance bottleneck.</p><ul><li>TODO: try replacing CSC with a Dict implementation of sparse matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL339-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.hcat!!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any}" href="#HierarchicalTemporalMemory.hcat!!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any}"><code>HierarchicalTemporalMemory.hcat!!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hcat!!(s::SparseMatrixCSC, I,V)</code></pre><p><em>WARNING</em>: <code>s</code> is invalid after this operation!!! Its symbol should be reassigned to the output of <code>hcat!!</code>. Append new columns to <code>s</code> with 1 value <code>V[c]</code> at row <code>I[c]</code> each. Because <code>SparseMatrixCSC</code> is immutable, return a new, valid <code>SparseMatrixCSC</code> that points to the original&#39;s data structures. For large matrices, this is <em>much</em> faster than <code>hcat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/array_utils.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.leastusedcell-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any}" href="#HierarchicalTemporalMemory.leastusedcell-Tuple{HierarchicalTemporalMemory.DistalSynapses, Any}"><code>HierarchicalTemporalMemory.leastusedcell</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>leastusedcell(s::DistalSynapses,col)</code> finds the neuron of a minicolumn with the fewest dendrites.</p><ul><li>TODO: try Memoize.jl !</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL370-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.predict!-Tuple{SDRClassifier, Any, Int64}" href="#HierarchicalTemporalMemory.predict!-Tuple{SDRClassifier, Any, Int64}"><code>HierarchicalTemporalMemory.predict!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict!(classifier::SDRClassifier, Œ†,target::Int; enable_learning=true)=</code></pre><p>Predict probability that the output represents each bucket of an arithmetic encoder. 0&lt;=predict!&lt;=1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/decoder.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.reverse_simpleArithmetic-Tuple{Vector{T} where T, Any, Any}" href="#HierarchicalTemporalMemory.reverse_simpleArithmetic-Tuple{Vector{T} where T, Any, Any}"><code>HierarchicalTemporalMemory.reverse_simpleArithmetic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse_simpleArithmetic(bucketProbDist, algorithm,params)</code></pre><p>Reverses the simple arithmetic encoder, given the same parameters. Inputs a probability distribution across all buckets and collapses it to a single arithmetic value, representing the most likely estimation in the timeseries&#39; domain (like a defuzzifier)</p><p><strong>Arguments</strong></p><ul><li>bucketProbDist [nbucket]: discrete probability of each bucket [0-1]</li><li>algorithm: {&#39;mean&#39;,&#39;mode&#39;,&#39;highmean&#39;} &#39;highmean&#39; is the mean of the highest-estimated values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/decoder.jl#LL36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}" href="#HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}"><code>HierarchicalTemporalMemory.sp_activate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>sp_activate(sp::SpatialPooler, z)</code> calculates the SP&#39;s output activation for given input activation <code>z</code>.</p><p><strong>Algorithm</strong></p><ol><li>Overlap <code>o(y·µ¢)</code><ul><li>Propagate the input activations through the proximal synapses (matrix multiply)</li><li>Apply boosting factors <code>b</code>: control mechanism that spreads out the activation pattern across understimulated neurons (homeostatic excitability control)</li></ul></li><li>Inhibition <code>Z</code> between <code>y·µ¢</code> (local/global): competition where only the top-k <code>y·µ¢</code> with the highest <code>o(y·µ¢)</code> win; ensures sparsity The competition happens within an area around each neuron.<ul><li><code>k</code>: number of winners depends on desired sparsity (<code>s</code>, see <a href="#HierarchicalTemporalMemory.SPParams"><code>SPParams</code></a>) and area size</li><li><code>Œ∏_inhibit</code>: inhibition threshold per neighborhood <span>$:= o(k-th y)$</span></li><li><code>Z(o(y·µ¢))</code>: convolution of <code>o</code> with <code>Œ∏_inhibit</code></li></ul></li><li>Activate winning <code>y·µ¢</code> &gt; activation threshold (<code>Œ∏_stimulus_activate</code>)</li></ol><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The local sparsity <code>s</code> tends to the sparsity of the entire layer as it grows larger, but for small values or small inhibition radius it diverges, because of the limited &amp; integral number of neurons winning in each neighborhood. This could be addressed by <em>tie breaking</em>, but it doesn&#39;t seem to have much practical importance.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/SpatialPooler.jl#LL122-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.sparse_foreach-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}" href="#HierarchicalTemporalMemory.sparse_foreach-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}"><code>HierarchicalTemporalMemory.sparse_foreach</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>sparse_foreach(f, s::SparseMatrixCSC,columnIdx)</code> iterates over the columns of the sparse matrix <code>s</code> specified by <code>columnIdx</code> and applies <code>f(columnElt,columnRowIdx)</code> to each. Column elements are a @view into the nonzero elements at the given column of <code>s</code>.</p><p>See also: <a href="#HierarchicalTemporalMemory.sparse_map-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}"><code>sparse_map</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.sparse_map-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}" href="#HierarchicalTemporalMemory.sparse_map-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}"><code>HierarchicalTemporalMemory.sparse_map</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>sparse_map(f, s::SparseMatrixCSC,columnIdx)</code> maps each column of the sparse matrix <code>s</code> specified by <code>columnIdx</code> to <code>f(columnElt,columnRowIdx)</code>. Column elements are a @view into the nonzero elements at the given column of <code>s</code>.</p><p>See also: <a href="#HierarchicalTemporalMemory.sparse_foreach-Tuple{Any, SparseArrays.SparseMatrixCSC, Any}"><code>sparse_foreach</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.step!-Tuple{HierarchicalTemporalMemory.ProximalSynapses, Any, Any, Any}" href="#HierarchicalTemporalMemory.step!-Tuple{HierarchicalTemporalMemory.ProximalSynapses, Any, Any, Any}"><code>HierarchicalTemporalMemory.step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>step!(s::ProximalSynapses, z,a, params)</code> adapts the proximal synapses&#39; permanences with a hebbian learning rule on input <code>z</code> and activation <code>a</code>. The adaptation has a causal and an anticausal component:</p><ul><li>If the postsynaptic neuron fires and the presynaptic fired too, the synapse is strengthened</li><li>If the postsynaptic neuron fires, but the presynaptic didn&#39;t, the synapse is weakened</li></ul><p>See alse: <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/dynamical_systems.jl#LL113-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.step!-Tuple{SpatialPooler, Any}" href="#HierarchicalTemporalMemory.step!-Tuple{SpatialPooler, Any}"><code>HierarchicalTemporalMemory.step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>step!(sp::SpatialPooler, z::CellActivity)</code> evolves the Spatial Pooler to the next timestep by evolving each of its constituents (synapses, boosting, inhibition radius) and returns the output activation.</p><p>See also: <a href="#HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}"><code>sp_activate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/SpatialPooler.jl#LL194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.step_boost!-Tuple{SpatialPooler, Any}" href="#HierarchicalTemporalMemory.step_boost!-Tuple{SpatialPooler, Any}"><code>HierarchicalTemporalMemory.step_boost!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>step_boost!(sp::SpatialPooler,a)</code> evolves the boosting factors <code>b</code> (see <a href="#HierarchicalTemporalMemory.sp_activate-Tuple{SpatialPooler, Any}"><code>sp_activate</code></a>). They depend on:</p><ul><li><code>√•‚Çú</code>: moving average in time activation of each minicolumn</li><li><code>√•‚Çô</code>: moving average in neighborhood activation of each minicolum</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/SpatialPooler.jl#LL213-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.tm_activate-Tuple{TemporalMemory, Any, Any}" href="#HierarchicalTemporalMemory.tm_activate-Tuple{TemporalMemory, Any, Any}"><code>HierarchicalTemporalMemory.tm_activate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>tm_activate(tm::TemporalMemory, c, Œ†)</code> calculates</p><ol><li>which minicolumns burst,</li><li>which neurons in the layer are activated</li><li>which become predictive</li></ol><p>for minicolumn activation <code>c</code> (size <code>Nc</code>) given by the <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a> and the previously predictive neurons <code>Œ†</code> (size <code>N‚Çô</code>).</p><p><strong>Returns</strong></p><ol><li><code>a</code>: neuron activation (<code>N‚Çô</code>)</li><li><code>B</code>: bursting minicolumns (<code>Nc</code>)</li><li><code>WN</code>: &quot;winning&quot; neurons (<code>N‚Çô</code>)</li></ol><p>See also: <a href="#HierarchicalTemporalMemory.tm_predict-Tuple{TemporalMemory, BitArray}"><code>tm_predict</code></a>, <a href="#HierarchicalTemporalMemory.DistalSynapses"><code>DistalSynapses</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/TemporalMemory.jl#LL164-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.tm_predict-Tuple{TemporalMemory, BitArray}" href="#HierarchicalTemporalMemory.tm_predict-Tuple{TemporalMemory, BitArray}"><code>HierarchicalTemporalMemory.tm_predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>tm_predict(tm::TemporalMemory, Œ±)</code> calculates which neurons will be predictive at the next step given the currently active neurons + distal input <code>Œ±</code>. <code>size(a)</code> must match the presynaptic length of <code>tm.distalSynapses</code>.</p><p><strong>Returns</strong></p><ol><li><code>Œ†</code>: predictive neurons (<code>N‚Çô</code>)</li><li><code>Œ†‚Çõ</code>: predictive dendritic segments (&#39;N‚Çõ&#39;) (caching)</li><li><code>M‚Çõ</code>: matching dendritic segments (<code>N‚Çõ</code>) (learning)</li><li><code>ovp_M‚Çõ</code>: subthreshold-matching dendritic segments (<code>N‚Çõ</code>) (learning)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/TemporalMemory.jl#LL197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.vcat!!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any}" href="#HierarchicalTemporalMemory.vcat!!-Tuple{SparseArrays.SparseMatrixCSC, Any, Any}"><code>HierarchicalTemporalMemory.vcat!!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcat!!(s::SparseMatrixCSC, J,V)</code></pre><p><em>WARNING</em>: <code>s</code> is invalid after this operation!!! Its symbol should be reassigned to the output of <code>vcat!!</code>. Append new rows to <code>s</code> with 1 value <code>V[r]</code> at column <code>J[r]</code> each. Because <code>SparseMatrixCSC</code> is immutable, return a new, valid <code>SparseMatrixCSC</code> that points to the original&#39;s data structures. For large matrices, this is much faster than <code>vcat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/array_utils.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.@percolumn-NTuple{4, Any}" href="#HierarchicalTemporalMemory.@percolumn-NTuple{4, Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p><code>@percolumn(f,a,b,k)</code></p><p>Macro to fold a large vector <code>a</code> per columns <code>k</code> and apply binary operator <code>f</code> elementwise</p><ul><li><code>a</code>: vector of size <code>Nc*k</code>, column-major (important because it will fold every <code>k</code> elements)</li><li><code>b</code>: vector of size <code>Nc</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.@percolumn-Tuple{Any, Any, Any}" href="#HierarchicalTemporalMemory.@percolumn-Tuple{Any, Any, Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p><code>@percolumn(reduce,a,k)</code></p><p>Macro to <code>reduce(a)</code> per column <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/778cb22eeb9bb2aa4164a3dffc2f7b5785e7866d/src/utils/iter_utils.jl#LL91-L95">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">¬´ Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Sunday 19 September 2021 15:25">Sunday 19 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
