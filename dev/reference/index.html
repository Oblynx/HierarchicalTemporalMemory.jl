<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference ¬∑ HierarchicalTemporalMemory.jl</title><link rel="canonical" href="https://oblynx.github.io/HierarchicalTemporalMemory.jl/reference/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HierarchicalTemporalMemory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Package-documentation-1"><a class="docs-heading-anchor" href="#Package-documentation-1">Package documentation</a><a class="docs-heading-anchor-permalink" href="#Package-documentation-1" title="Permalink"></a></h1><ul><li><a href="#HierarchicalTemporalMemory.ùïäùï¢range"><code>HierarchicalTemporalMemory.ùïäùï¢range</code></a></li><li><a href="#HierarchicalTemporalMemory.CellActivity"><code>HierarchicalTemporalMemory.CellActivity</code></a></li><li><a href="#HierarchicalTemporalMemory.Hypercube"><code>HierarchicalTemporalMemory.Hypercube</code></a></li><li><a href="#HierarchicalTemporalMemory.Hypersphere"><code>HierarchicalTemporalMemory.Hypersphere</code></a></li><li><a href="#HierarchicalTemporalMemory.InhibitionRadius"><code>HierarchicalTemporalMemory.InhibitionRadius</code></a></li><li><a href="#HierarchicalTemporalMemory.LengthfulIter"><code>HierarchicalTemporalMemory.LengthfulIter</code></a></li><li><a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>HierarchicalTemporalMemory.ProximalSynapses</code></a></li><li><a href="#HierarchicalTemporalMemory.SPParams"><code>HierarchicalTemporalMemory.SPParams</code></a></li><li><a href="#HierarchicalTemporalMemory.Sequence"><code>HierarchicalTemporalMemory.Sequence</code></a></li><li><a href="#HierarchicalTemporalMemory.SpatialPooler-Tuple{Any}"><code>HierarchicalTemporalMemory.SpatialPooler</code></a></li><li><a href="#HierarchicalTemporalMemory.SpatialPooler"><code>HierarchicalTemporalMemory.SpatialPooler</code></a></li><li><a href="#HierarchicalTemporalMemory.TMParams"><code>HierarchicalTemporalMemory.TMParams</code></a></li><li><a href="#HierarchicalTemporalMemory.TemporalMemory"><code>HierarchicalTemporalMemory.TemporalMemory</code></a></li><li><a href="#HierarchicalTemporalMemory.Truesof"><code>HierarchicalTemporalMemory.Truesof</code></a></li><li><a href="#HierarchicalTemporalMemory.ùïäùï¢"><code>HierarchicalTemporalMemory.ùïäùï¢</code></a></li><li><a href="#HierarchicalTemporalMemory.bitarray-Tuple{Any,Any}"><code>HierarchicalTemporalMemory.bitarray</code></a></li><li><a href="#HierarchicalTemporalMemory.hcat!!-Tuple{SparseArrays.SparseMatrixCSC,Any,Any}"><code>HierarchicalTemporalMemory.hcat!!</code></a></li><li><a href="#HierarchicalTemporalMemory.predict!-Tuple{SDRClassifier,Any,Int64}"><code>HierarchicalTemporalMemory.predict!</code></a></li><li><a href="#HierarchicalTemporalMemory.reverse_simpleArithmetic-Tuple{Array{T,1} where T,Any,Any}"><code>HierarchicalTemporalMemory.reverse_simpleArithmetic</code></a></li><li><a href="#HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin"><code>HierarchicalTemporalMemory.sp_activate</code></a></li><li><a href="#HierarchicalTemporalMemory.sparse_foreach-Tuple{Any,SparseArrays.SparseMatrixCSC,Any}"><code>HierarchicalTemporalMemory.sparse_foreach</code></a></li><li><a href="#HierarchicalTemporalMemory.step!-Tuple{HierarchicalTemporalMemory.ProximalSynapses,Any,Any,Any}"><code>HierarchicalTemporalMemory.step!</code></a></li><li><a href="#HierarchicalTemporalMemory.step!-Tuple{SpatialPooler,Any}"><code>HierarchicalTemporalMemory.step!</code></a></li><li><a href="#HierarchicalTemporalMemory.step_boost!-Tuple{SpatialPooler,Any}"><code>HierarchicalTemporalMemory.step_boost!</code></a></li><li><a href="#HierarchicalTemporalMemory.vcat!!-Tuple{SparseArrays.SparseMatrixCSC,Any,Any}"><code>HierarchicalTemporalMemory.vcat!!</code></a></li><li><a href="#HierarchicalTemporalMemory.@percolumn-NTuple{4,Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a></li><li><a href="#HierarchicalTemporalMemory.@percolumn-Tuple{Any,Any,Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Hypercube" href="#HierarchicalTemporalMemory.Hypercube"><code>HierarchicalTemporalMemory.Hypercube</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Hypercube iterates over a hypercube of radius Œ≥ around x·∂ú, bounded inside the space {1..sz}·¥∫.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; hc= Hypercube((3,3),1,(10,10));

julia&gt; foreach(println, hc)
(2, 2)
(3, 2)
(4, 2)
(2, 3)
(3, 3)
(4, 3)
(2, 4)
(3, 4)
(4, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/topology.jl#LL1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Hypersphere" href="#HierarchicalTemporalMemory.Hypersphere"><code>HierarchicalTemporalMemory.Hypersphere</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Hypersphere is approximated with a Hypercube for simplicity</p><p>See also: <a href="#HierarchicalTemporalMemory.Hypercube"><code>Hypercube</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/topology.jl#LL48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.SPParams" href="#HierarchicalTemporalMemory.SPParams"><code>HierarchicalTemporalMemory.SPParams</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>SPParams{Nin,Nsp} holds the algorithm parameters for a spatial pooler with nomenclature similar to <a href="https://www.frontiersin.org/articles/10.3389/fncom.2017.00111/full">source</a></p><p>The dimension parameters are problem-specific and should be the first to be specified.</p><p>The tuning parameters have sensible defaults, which should be . All gated features are enabled by default.</p><p><strong>Parameters</strong></p><p><strong>Dimensions</strong></p><ul><li><code>sz·µ¢‚Çô</code>, <code>sz‚Çõ‚Çö</code>: input/output dimensions</li><li><code>Œ≥</code>: receptive field radius (how large an input area an output minicolumn maps to)</li></ul><p><strong>Algorithm tuning</strong></p><ul><li><code>s</code>: average output sparsity</li><li><code>prob_synapse</code>: probability for each element of the <code>sz·µ¢‚Çô √ó sz‚Çõ‚Çö</code> space to be a synapse. Elements that roll below this value don&#39;t form a synapse and don&#39;t get a permanence value. If this is very low, the proximal synapses matrix can become sparse.</li><li><code>Œ∏_permanence01</code>: synapse permanence connection threshold</li><li><code>p‚Å∫_01</code>,<code>p‚Åª_01</code>: synapse permanence adaptation rate (see <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>)</li><li><code>Œ∏_stimulus_activate</code>: minicolumn absolute activation threshold</li><li><code>Tboost</code>: boosting mechanism&#39;s moving average filter period</li><li><code>Œ≤</code>: boosting strength</li></ul><p><strong>Feature gates</strong></p><ul><li><code>enable_local_inhibit</code></li><li><code>enable_learning</code></li><li><code>enable_boosting</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.SpatialPooler" href="#HierarchicalTemporalMemory.SpatialPooler"><code>HierarchicalTemporalMemory.SpatialPooler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>SpatialPooler{Nin,Nsp}</code> is a learning algorithm that decorrelates the features of an input space, producing a Sparse Distributed Representation (SDR) of the input space. If defines the proximal connections of an HTM layer.</p><p><strong>Examples</strong></p><pre><code class="language-julia">sp= SpatialPooler(SPParams(sz·µ¢‚Çô=(600,), sz‚Çõ‚Çö=(2048,)))
z= Random.bitrand(600)  # input
activation= sp(z)
# or, to adapt the SP to the input as well:
activation= step!(sp,z)</code></pre><p><strong>Properties</strong></p><p>It&#39;s called <code>SpatialPooler</code> because input patterns that share a large number of co-active neurons (i.e., that are spatially similar) are grouped together into a common output representation. It is designed to achieve a set of <em>computational properties</em> that support further downstream computations with SDRs, including:</p><ul><li>preserving topology of the input space by mapping similar inputs to similar outputs</li><li>continuously adapting to changing statistics of the input stream</li><li>forming fixed sparsity representations</li><li>being robust to noise</li><li>being fault tolerant</li></ul><p><a href="https://www.frontiersin.org/articles/10.3389/fncom.2017.00111/full">Source</a></p><p><strong>Algorithm overview</strong></p><p><strong>Mapping I/O spaces</strong></p><p>The spatial pooler maps an input space <code>x</code> to an output space <code>y</code> of minicolumns through a matrix of proximal synapses. The input space can optionally have a topology, which the spatial pooler will preserve by mapping output minicolumn <code>y·µ¢</code> to a subset of the input space, a <a href="#HierarchicalTemporalMemory.Hypercube"><code>Hypercube</code></a> around center <code>x·∂ú</code>. <code>julia x·∂ú(y·µ¢)= floor.(Int, (y·µ¢.-1) .* (sz·µ¢‚Çô./sz‚Çõ‚Çö)) .+1</code>`</p><p><strong>Output activation</strong></p><ol><li>Calculate the overlap <code>o(y·µ¢)</code> by propagating the input activations through the proximal synapses and adjusting by boosting factors <code>b</code> (control mechanism that spreads out the activation pattern across understimulated neurons)</li><li>Inhibition <code>Z</code> between <code>y·µ¢</code> (local/global): competition where only the top-K <code>y·µ¢</code> with the highest <code>o(y·µ¢)</code> win; ensures sparsity</li><li>Activate winning <code>y·µ¢</code> &gt; activation threshold (<code>Œ∏_stimulus_activate</code>)</li></ol><p>See also: <a href="#HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin"><code>sp_activate</code></a></p><p><strong>State variables</strong></p><ul><li><code>synapses</code>: includes the synapse permanence matrix D‚Çö</li><li><code>√•‚Çú</code>: [boosting] moving (in time) average (in time) activation of each minicolumn</li><li><code>√•‚Çô</code>: [boosting] moving (in time) average (in neighborhood) activation of each minicolumn</li><li><code>œÜ</code>: the adaptible radius of local inhibition</li></ul><hr/><p>See also: <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a>, <a href="#HierarchicalTemporalMemory.TemporalMemory"><code>TemporalMemory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/SpatialPooler.jl#LL6-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.SpatialPooler-Tuple{Any}" href="#HierarchicalTemporalMemory.SpatialPooler-Tuple{Any}"><code>HierarchicalTemporalMemory.SpatialPooler</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the activation pattern of the <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a> for the given input activation.</p><p><code>z</code>: <a href="#HierarchicalTemporalMemory.CellActivity"><code>CellActivity</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia">sp= SpatialPooler(SPParams(sz·µ¢‚Çô=(600,), sz‚Çõ‚Çö=(2048,)))
z= Random.bitrand(600)  # input
activation= sp(z)
# or, to adapt the SP to the input as well:
activation= step!(sp,z)</code></pre><p>For details see: <a href="#HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin"><code>sp_activate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/SpatialPooler.jl#LL99-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.TMParams" href="#HierarchicalTemporalMemory.TMParams"><code>HierarchicalTemporalMemory.TMParams</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>TMParams</code> holds the algorithm parameters for a Temporal Memory with nomenclature similar to <a href=".">source</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.TemporalMemory" href="#HierarchicalTemporalMemory.TemporalMemory"><code>HierarchicalTemporalMemory.TemporalMemory</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>TemporalMemory</code> learns to predict sequences of input Sparse Distributed Representations (SDRs), usually generated by a <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a>. It learns to represent each input symbol in the temporal context of the symbols that come before it in the sequence, using the individual neurons of each minicolumn and their distal synapses.</p><p>When considering a neuron layer with proximal and distal synapses, the spatial pooler is a way to activate and learn the proximal synapses, while the temporal memory is a way to activate and learn the distal synapses.</p><p><strong>TM activation</strong></p><p>An SDR input activates some minicolumns of the neuron layer.</p><hr/><p>See also: <a href="@ref"><code>TMState</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/TemporalMemory.jl#LL18-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.predict!-Tuple{SDRClassifier,Any,Int64}" href="#HierarchicalTemporalMemory.predict!-Tuple{SDRClassifier,Any,Int64}"><code>HierarchicalTemporalMemory.predict!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">predict!(classifier::SDRClassifier, Œ†,target::Int; enable_learning=true)=</code></pre><p>Predict probability that the output represents each bucket of an arithmetic encoder. 0&lt;=predict!&lt;=1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/decoder.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.reverse_simpleArithmetic-Tuple{Array{T,1} where T,Any,Any}" href="#HierarchicalTemporalMemory.reverse_simpleArithmetic-Tuple{Array{T,1} where T,Any,Any}"><code>HierarchicalTemporalMemory.reverse_simpleArithmetic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reverse_simpleArithmetic(bucketProbDist, algorithm,params)</code></pre><p>Reverses the simple arithmetic encoder, given the same parameters. Inputs a probability distribution across all buckets and collapses it to a single arithmetic value, representing the most likely estimation in the timeseries&#39; domain (like a defuzzifier)</p><p><strong>Arguments</strong></p><ul><li>bucketProbDist [nbucket]: discrete probability of each bucket [0-1]</li><li>algorithm: {&#39;mean&#39;,&#39;mode&#39;,&#39;highmean&#39;} &#39;highmean&#39; is the mean of the highest-estimated values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/decoder.jl#LL36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.step!-Tuple{HierarchicalTemporalMemory.ProximalSynapses,Any,Any,Any}" href="#HierarchicalTemporalMemory.step!-Tuple{HierarchicalTemporalMemory.ProximalSynapses,Any,Any,Any}"><code>HierarchicalTemporalMemory.step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>step!(s::ProximalSynapses, z,a, params)</code> adapts the proximal synapses&#39; permanences with a hebbian learning rule on input <code>z</code> and activation <code>a</code>. The adaptation has a causal and an anticausal component:</p><ul><li>If the postsynaptic neuron fires and the presynaptic fired too, the synapse is strengthened</li><li>If the postsynaptic neuron fires, but the presynaptic didn&#39;t, the synapse is weakened</li></ul><p>See alse: <a href="#HierarchicalTemporalMemory.ProximalSynapses"><code>ProximalSynapses</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/dynamical_systems.jl#LL147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.step!-Tuple{SpatialPooler,Any}" href="#HierarchicalTemporalMemory.step!-Tuple{SpatialPooler,Any}"><code>HierarchicalTemporalMemory.step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>step!(sp::SpatialPooler, z::CellActivity)</code> evolves the Spatial Pooler to the next timestep by evolving each of its constituents (synapses, boosting, inhibition radius) and returns the output activation.</p><p>See also: <a href="#HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin"><code>sp_activate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/SpatialPooler.jl#LL186-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.ùïäùï¢range" href="#HierarchicalTemporalMemory.ùïäùï¢range"><code>HierarchicalTemporalMemory.ùïäùï¢range</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>ùïäùï¢range is the domain of connection permanence quantization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/HierarchicalTemporalMemory.jl#LL19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.CellActivity" href="#HierarchicalTemporalMemory.CellActivity"><code>HierarchicalTemporalMemory.CellActivity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Type of neuron layer activations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/HierarchicalTemporalMemory.jl#LL22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.InhibitionRadius" href="#HierarchicalTemporalMemory.InhibitionRadius"><code>HierarchicalTemporalMemory.InhibitionRadius</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The inhibition radius of a Spatial Pooler&#39;s columns is a dynamical system that evolves under the influence of other elements of the Spatial Pooler. It provides an init (constructor) and a step! function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/dynamical_systems.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.LengthfulIter" href="#HierarchicalTemporalMemory.LengthfulIter"><code>HierarchicalTemporalMemory.LengthfulIter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Iterator transformations, like filters, don&#39;t keep the length info. <code>LengthfulIter</code> is a wrapper that allows length info known programmatically to be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.ProximalSynapses" href="#HierarchicalTemporalMemory.ProximalSynapses"><code>HierarchicalTemporalMemory.ProximalSynapses</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>ProximalSynapses{SynapseT&lt;:AnySynapses,ConnectedT&lt;:AnyConnection} are the feedforward connections of 2 neuron layers.</p><p>Used in the context of the <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a>.</p><p><strong>Description</strong></p><p>The neurons of both layers are expected to form minicolumns which share the same feedforward connections. The synapses are <em>binary</em>: they don&#39;t have a scalar weight, but either conduct (1) or not (0). Instead, they have a <em>permanence</em> value D‚Çö ‚àà (0,1] and a connection threshold Œ∏.</p><p><strong>Initialization</strong></p><p>Let presynaptic (input) neuron <code>x·µ¢</code> and postsynaptic (output) neuron <code>y·µ¢</code>, and a topological I/O mapping <code>x·µ¢(y·µ¢) :=</code> <a href="#HierarchicalTemporalMemory.Hypercube"><code>Hypercube</code></a><code>(y·µ¢)</code>. ‚àÄ</p><p><strong>Synapse adaptation</strong></p><p>They adapt with a hebbian learning rule. The adaptation has a causal and an anticausal component:</p><ul><li>If the postsynaptic neuron fires and the presynaptic fired too, the synapse is strengthened</li><li>If the postsynaptic neuron fires, but the presynaptic didn&#39;t, the synapse is weakened</li></ul><p>The synaptic permanences are clipped at the boundaries of 0 and 1.</p><p>A simple implementation of the learning rule would look like this, where z: input, a: output</p><pre><code class="language-julia">learn!(D‚Çö,z,a)= begin
  D‚Çö[z,a]  .= (D‚Çö[z,a].&gt;0) .* (D‚Çö[z,a]   .‚äï p‚Å∫)
  D‚Çö[.!z,a].= (D‚Çö[z,a].&gt;0) .* (D‚Çö[.!z,a] .‚äñ p‚Åª)
end</code></pre><p><strong>Type parameters</strong></p><p>They allow a dense or sparse matrix representation of the synapses</p><ul><li><code>SynapseT</code>: <code>DenseSynapses</code> or <code>SparseSynapses</code></li><li><code>ConnectedT</code>: <code>DenseConnection</code> or <code>SparseConnection</code></li></ul><p>See also: <a href="@ref"><code>DistalSynapses</code></a>, <a href="#HierarchicalTemporalMemory.SpatialPooler"><code>SpatialPooler</code></a>, <a href="#HierarchicalTemporalMemory.TemporalMemory"><code>TemporalMemory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/dynamical_systems.jl#LL46-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Sequence" href="#HierarchicalTemporalMemory.Sequence"><code>HierarchicalTemporalMemory.Sequence</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p><code>Sequence(;Œ¥,init)</code> is an easy way to define sequences with transition function <code>Œ¥</code> and starting condition <code>init</code> as an iterator.</p><p><strong>Examples</strong></p><p>Fibonacci sequence:</p><pre><code class="language-julia">fibonacci_Œ¥(a,b)= b, a+b;
fibonacci_init= 0,1;
Lazy.@as _1 HTM.Sequence(fibonacci_Œ¥, fibonacci_init) IterTools.take(_1, 13) foreach(println, _1)

# output
0
1
1
2
3
5
8
13
21
34
55
89
144</code></pre><p>Factorial sequence:</p><pre><code class="language-julia">factorial_Œ¥(a,b)= a*b, b+1;
factorial_init= 1,1;
Lazy.@as _1 HTM.Sequence(factorial_Œ¥, factorial_init) IterTools.take(_1, 13) foreach(println, _1)

# output
1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL106-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.Truesof" href="#HierarchicalTemporalMemory.Truesof"><code>HierarchicalTemporalMemory.Truesof</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Iterate over the trues of a BitArray</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; b= Random.bitrand(5)
5-element BitArray{1}:
 1
 0
 0
 1
 1

julia&gt; foreach(i-&gt; print(string(i)*&quot; &quot;), HTM.Truesof(b))
1 4 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.ùïäùï¢" href="#HierarchicalTemporalMemory.ùïäùï¢"><code>HierarchicalTemporalMemory.ùïäùï¢</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>ùïäùï¢ is the type of connection permanences, defining their quantization domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/HierarchicalTemporalMemory.jl#LL17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.bitarray-Tuple{Any,Any}" href="#HierarchicalTemporalMemory.bitarray-Tuple{Any,Any}"><code>HierarchicalTemporalMemory.bitarray</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bitarray(dims, idx)</code></pre><p>Create a bitarray with <code>true</code> only at <code>idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.hcat!!-Tuple{SparseArrays.SparseMatrixCSC,Any,Any}" href="#HierarchicalTemporalMemory.hcat!!-Tuple{SparseArrays.SparseMatrixCSC,Any,Any}"><code>HierarchicalTemporalMemory.hcat!!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hcat!!(s::SparseMatrixCSC, I,V)</code></pre><p><em>WARNING</em>: <code>s</code> is invalid after this operation!!! Its symbol should be reassigned to the output of <code>hcat!!</code>. Append new columns to <code>s</code> with 1 value <code>V[c]</code> at row <code>I[c]</code> each. Because <code>SparseMatrixCSC</code> is immutable, return a new, valid <code>SparseMatrixCSC</code> that points to the original&#39;s data structures. For large matrices, this is <em>much</em> faster than <code>hcat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/array_utils.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin" href="#HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin"><code>HierarchicalTemporalMemory.sp_activate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>sp_activate(sp::SpatialPooler{Nin,Nsp}, z)</code> calculates the SP&#39;s output activation for given input activation <code>z</code>.</p><p><strong>Algorithm</strong></p><ol><li>Overlap <code>o(y·µ¢)</code><ul><li>Propagate the input activations through the proximal synapses (matrix multiply)</li><li>Apply boosting factors <code>b</code>: control mechanism that spreads out the activation pattern across understimulated neurons (homeostatic excitability control)</li></ul></li><li>Inhibition <code>Z</code> between <code>y·µ¢</code> (local/global): competition where only the top-k <code>y·µ¢</code> with the highest <code>o(y·µ¢)</code> win; ensures sparsity The competition happens within an area around each neuron.<ul><li><code>k</code>: number of winners depends on desired sparsity (<code>s</code>, see <a href="#HierarchicalTemporalMemory.SPParams"><code>SPParams</code></a>) and area size</li><li><code>Œ∏_inhibit</code>: inhibition threshold per neighborhood <span>$:= o(k-th y)$</span></li><li><code>Z(o(y·µ¢))</code>: convolution of <code>o</code> with <code>Œ∏_inhibit</code></li></ul></li><li>Activate winning <code>y·µ¢</code> &gt; activation threshold (<code>Œ∏_stimulus_activate</code>)</li></ol><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The local sparsity <code>s</code> tends to the sparsity of the entire layer as it grows larger, but for small values or small inhibition radius it diverges, because of the limited &amp; integral number of neurons winning in each neighborhood. This could be addressed by <em>tie breaking</em>, but it doesn&#39;t seem to have much practical importance.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/SpatialPooler.jl#LL117-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.sparse_foreach-Tuple{Any,SparseArrays.SparseMatrixCSC,Any}" href="#HierarchicalTemporalMemory.sparse_foreach-Tuple{Any,SparseArrays.SparseMatrixCSC,Any}"><code>HierarchicalTemporalMemory.sparse_foreach</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sparse_foreach(f, s::SparseMatrixCSC,columnIdx)</code></pre><p>Iterate SparseMatrix <code>s</code> and apply <code>f</code> columnwise (<code>f(s,nzrange,rowvals)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.step_boost!-Tuple{SpatialPooler,Any}" href="#HierarchicalTemporalMemory.step_boost!-Tuple{SpatialPooler,Any}"><code>HierarchicalTemporalMemory.step_boost!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p><code>step_boost!(sp::SpatialPooler,a)</code> evolves the boosting factors <code>b</code> (see <a href="#HierarchicalTemporalMemory.sp_activate-Union{Tuple{Nsp}, Tuple{Nin}, Tuple{SpatialPooler{Nin,Nsp},Any}} where Nsp where Nin"><code>sp_activate</code></a>). They depend on:</p><ul><li><code>√•‚Çú</code>: moving average in time activation of each minicolumn</li><li><code>√•‚Çô</code>: moving average in neighborhood activation of each minicolum</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/SpatialPooler.jl#LL163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.vcat!!-Tuple{SparseArrays.SparseMatrixCSC,Any,Any}" href="#HierarchicalTemporalMemory.vcat!!-Tuple{SparseArrays.SparseMatrixCSC,Any,Any}"><code>HierarchicalTemporalMemory.vcat!!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vcat!!(s::SparseMatrixCSC, J,V)</code></pre><p><em>WARNING</em>: <code>s</code> is invalid after this operation!!! Its symbol should be reassigned to the output of <code>vcat!!</code>. Append new rows to <code>s</code> with 1 value <code>V[r]</code> at column <code>J[r]</code> each. Because <code>SparseMatrixCSC</code> is immutable, return a new, valid <code>SparseMatrixCSC</code> that points to the original&#39;s data structures. For large matrices, this is much faster than <code>vcat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/array_utils.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.@percolumn-NTuple{4,Any}" href="#HierarchicalTemporalMemory.@percolumn-NTuple{4,Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p>@percolumn(f,a,b,k,Ncol)</p><p>Macro to apply <code>f</code> elementwise and concatenate the results.</p><ul><li><code>a</code>: vector of size [<code>Ncol</code>*<code>k</code>], column-major</li><li><code>b</code>: vectors of size <code>Ncol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HierarchicalTemporalMemory.@percolumn-Tuple{Any,Any,Any}" href="#HierarchicalTemporalMemory.@percolumn-Tuple{Any,Any,Any}"><code>HierarchicalTemporalMemory.@percolumn</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p>@percolumn(reduce,a,k,Ncol)</p><p>Macro to <code>reduce</code> <code>a</code> per column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oblynx/HierarchicalTemporalMemory.jl/blob/e8dafda616be6d99f50d3b1c79053251795d9c24/src/utils/iter_utils.jl#LL79-L83">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">¬´ Examples</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 17 July 2020 12:46">Friday 17 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
